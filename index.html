<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phasmophobia Broads HQ Command Center</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts: Orbitron (Headers) and JetBrains Mono (Data/Logs) -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons (using thin-line aesthetic where possible) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Tone.js for Web Audio Synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/tone.min.js"></script>
    <style>
        /* --- 1. COHESIVE COLOR PALETTE & VARIABLES --- */
        :root {
            --neon-purple: #b71cff; /* Primary Accent */
            --deep-black: #0a0a0f; /* Background/Card Base */
            --soft-cyan: #5dfdff; /* Secondary Glow/Highlight */
            --card-bg-transparent: rgba(255, 255, 255, 0.05); /* Semi-transparent white */
            --card-radius: 16px;
            --section-padding: 24px;
        }

        /* --- 3. MODERN FONT DUO --- */
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .font-mono-data { font-family: 'JetBrains Mono', monospace; }

        body {
            font-family: 'Montserrat', sans-serif; /* Fallback Primary Font */
            background-color: var(--deep-black);
            color: #e0e0e0; /* Off-white text */
            /* Dark, subtle texture for paranormal sci-fi theme */
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%231f2937' fill-opacity='0.1'%3E%3Cpath d='M36 34L30 30.9138V29.0862L36 26V34zm6-3l-6-3.0862v-1.8276L42 28V31zm-6-8.9138L42 19V22L36 25.0862V22zm0-2.1724V16L42 13V19L36 15.9138zM24 22v3.0862L30 22v-3.0862L24 16zM30 15.9138L24 13V16L30 19.0862V15.9138zm0 18.1724V31L24 28V26l6 3.0862V34zm0 2.1724V34L24 37V40l6-3.0862V36.2586zm0 2.1724V37L24 40V43l6-3.0862V38.431zM36 36.2586L30 33.1724V37L36 40V36.2586zm0 2.1724V37L30 40V43L36 39.8276V38.431zM24 10.0862V7L30 4V7L24 10.0862zM30 4V7L24 10.0862V13L30 9.9138z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }

        /* --- 4. SEMI-TRANSPARENT CARDS & 2. CONSISTENT RADIUS/PADDING --- */
        .phasmo-card {
            background-color: var(--card-bg-transparent);
            border: 1px solid var(--neon-purple);
            border-radius: var(--card-radius);
            padding: var(--section-padding);
            box-shadow: 0 0 10px rgba(183, 28, 255, 0.4), /* Neon Purple Outer Glow */
                        inset 0 0 5px rgba(255, 255, 255, 0.1); /* Subtle inner shadow */
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease-in-out;
        }

        /* --- 5. HIERARCHY & TITLES --- */
        .phasmo-title {
            color: var(--soft-cyan);
            text-shadow: 0 0 8px rgba(93, 253, 255, 0.6);
            border-bottom: 1px solid rgba(183, 28, 255, 0.3); /* Thin neon divider */
            padding-bottom: 8px;
            margin-bottom: 16px;
        }

        .phasmo-subtitle {
            color: var(--neon-purple);
            text-shadow: 0 0 5px rgba(183, 28, 255, 0.4);
            margin-bottom: 12px;
        }

        /* --- 8. BUTTON GLOW ON HOVER --- */
        .phasmo-btn {
            background-color: var(--deep-black);
            border: 1px solid var(--neon-purple);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(183, 28, 255, 0.6);
        }

        .phasmo-btn:hover {
            border-color: var(--soft-cyan);
            box-shadow: 0 0 15px rgba(183, 28, 255, 0.9), 0 0 8px rgba(93, 253, 255, 0.5);
            transform: scale(1.02);
            cursor: crosshair;
        }

        /* --- EMF Bar Styling --- */
        .emf-bar-container {
            border: 1px solid var(--soft-cyan);
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 5px var(--soft-cyan);
        }

        .emf-bar {
            transition: width 0.3s ease-in-out;
        }

        /* --- Log/Chat Clean Containers (9. CLEAN LOGS) --- */
        .log-container {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(183, 28, 255, 0.3);
            border-radius: 8px;
            padding: 16px;
        }

        .log-entry {
            line-height: 1.5;
        }
        .log-entry-command { color: var(--soft-cyan); }
        .log-entry-event { color: #ff5d5d; /* Red for danger */ }

        /* --- Dropdown Fix (Guaranteed Visibility) --- */
        select {
            color: white !important;
            background-color: #111827 !important; /* Force dark gray/black background */
        }
        select option {
            color: white !important;
            background-color: #111827 !important;
        }


        /* --- Jump Scare Visual Effects --- */
        .scare-flicker { animation: flicker 0.2s 5 alternate; }
        .scare-shake { animation: shake 0.5s 1 alternate; }

        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.2; }
            100% { opacity: 1; }
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            25% { transform: translate(-1px, -2px) rotate(-1deg); }
            50% { transform: translate(3px, 2px) rotate(0deg); }
            75% { transform: translate(-3px, 1px) rotate(1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* --- Modal Backdrop --- */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(8px);
        }

        .modal-content {
            border: 3px solid var(--soft-cyan);
            box-shadow: 0 0 60px rgba(93, 253, 255, 0.8);
            background-color: var(--deep-black);
        }

        /* Active Tab Styling */
        .tab-button.active-tab {
            background-color: var(--neon-purple) !important;
            color: white !important;
            border-color: var(--soft-cyan) !important;
            box-shadow: 0 0 15px rgba(183, 28, 255, 0.8) !important;
        }
        .tab-button:not(.active-tab) {
             background-color: var(--deep-black);
             border: 1px solid var(--neon-purple);
             color: var(--soft-cyan);
        }

    </style>
</head>
<body class="p-6 sm:p-10 min-h-screen">

    <!-- Global Error/Info Alert -->
    <div id="alert-box" class="fixed top-6 right-6 z-50 p-4 rounded-lg shadow-xl hidden transition-opacity duration-300" role="alert"></div>

    <div id="app-container" class="max-w-7xl mx-auto space-y-8">
        <!-- 1. HEADER (Full Width, Centered) -->
        <div class="text-center phasmo-card py-6">
            <h1 class="text-6xl font-extrabold uppercase font-orbitron phasmo-title mb-2 pb-0 tracking-widest">
                Phasmophobia Broads HQ
            </h1>
            <p class="text-sm text-gray-400 font-mono-data mt-2">
                Level 5 Command Center // STATUS: <span id="user-id-display" class="text-soft-cyan">AWAITING AUTHORIZATION...</span>
            </p>
        </div>

        <!-- 2. MAIN PANELS (Two Side-by-Side) -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">

            <!-- LEFT PANEL: Ghost Activity Monitor + Ghost Log -->
            <div class="col-span-1 flex flex-col space-y-6">

                <!-- GHOST ACTIVITY MONITOR (EMF & Hunt Button) -->
                <div class="phasmo-card">
                    <h2 class="phasmo-subtitle text-xl font-orbitron mb-3 flex justify-between items-center">
                        GHOST ACTIVITY MONITOR
                        <span id="emf-level-text" class="text-soft-cyan text-2xl font-mono-data">OFF</span>
                    </h2>
                    <div class="emf-bar-container w-full h-6 rounded-sm overflow-hidden mb-4">
                        <div id="emf-bar" class="emf-bar h-full" style="width: 0%;"></div>
                    </div>
                    <button onclick="triggerGlobalEvent('hunt')" class="phasmo-btn bg-red-800 border-red-500 hover:bg-red-900 font-orbitron py-3 px-4 uppercase text-sm w-full shadow-red-500/50">
                        <i class="fas fa-ghost mr-2"></i> Trigger Hunt Event (Global)
                    </button>
                </div>

                <!-- GHOST LOG & COMMAND INPUT -->
                <div class="phasmo-card flex-grow flex flex-col min-h-[40vh] lg:min-h-0">
                    <h2 class="phasmo-subtitle text-xl font-orbitron mb-4">GHOST ACTIVITY LOG</h2>
                    <div id="ghost-activity-log" class="log-container flex-grow overflow-y-auto space-y-1 font-mono-data text-sm">
                        <!-- Log entries will be injected here -->
                        <p class="text-gray-400 log-entry">[SYSTEM] Awaiting initial authentication...</p>
                    </div>

                    <!-- Command Input -->
                    <div class="mt-4">
                        <input type="text" id="chat-input" placeholder="Type message or command (!hunt, !dead:NAME, etc.)" class="w-full p-3 bg-deep-black border-2 border-neon-purple rounded-lg focus:ring-soft-cyan focus:border-soft-cyan text-soft-cyan font-mono-data text-base shadow-lg" onkeydown="handleChatInput(event)">
                        <div class="text-xs text-gray-500 font-mono-data mt-1">Available commands: !hunt, !flicker, !manifest, !curse, !slam, !event, !evidence:X, !dead:X, !revive:X, !location:X</div>
                    </div>
                </div>

            </div>

            <!-- RIGHT PANEL: Data Terminal (Tabs) + Squad Status -->
            <div class="col-span-1 flex flex-col space-y-6">

                <!-- DATA TERMINAL (Tabs Container) -->
                <div class="phasmo-card flex-grow flex flex-col min-h-[40vh] lg:min-h-0">
                    <h2 class="phasmo-subtitle text-xl font-orbitron mb-4">DATA TERMINAL</h2>

                    <!-- Tab Buttons -->
                    <div class="flex flex-wrap gap-2 mb-6 justify-center">
                        <button id="tab-btn-chat" onclick="switchTab('chat')" class="tab-button px-4 py-2 phasmo-btn text-sm font-semibold">
                            <i class="fas fa-comments"></i> Chat
                        </button>
                        <button id="tab-btn-evidence" onclick="switchTab('evidence')" class="tab-button px-4 py-2 phasmo-btn text-sm font-semibold">
                            <i class="fas fa-fingerprint"></i> Evidence
                        </button>
                        <button id="tab-btn-log" onclick="switchTab('log')" class="tab-button px-4 py-2 phasmo-btn text-sm font-semibold">
                            <i class="fas fa-book"></i> Ghost Profile
                        </button>
                        <button id="tab-btn-casefiles" onclick="switchTab('casefiles')" class="tab-button px-4 py-2 phasmo-btn text-sm font-semibold">
                            <i class="fas fa-folder-open"></i> Cases
                        </button>
                        <button id="tab-btn-squad" onclick="switchTab('squad')" class="tab-button px-4 py-2 phasmo-btn text-sm font-semibold">
                            <i class="fas fa-users"></i> Squad
                        </button>
                        <button id="tab-btn-lobby" onclick="switchTab('lobby')" class="tab-button px-4 py-2 phasmo-btn text-sm font-semibold">
                            <i class="fas fa-id-card"></i> Profile
                        </button>
                    </div>

                    <!-- Tab Content Area -->
                    <div id="tab-content" class="flex-grow">
                        <!-- Tab: Chat (Initial tab, always visible) -->
                        <div id="tab-chat" class="tab-page hidden">
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">Squad Comms Log</h3>
                            <div id="chat-messages" class="log-container h-[20rem] overflow-y-auto space-y-3 font-mono-data text-sm">
                                <!-- Messages will be injected here -->
                            </div>
                        </div>

                        <!-- Tab: Evidence Tracker -->
                        <div id="tab-evidence" class="tab-page hidden">
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">Collected Evidence</h3>
                            <div id="evidence-display" class="space-y-3 text-sm font-mono-data h-[20rem] overflow-y-auto log-container">
                                <!-- Evidence items will be injected here -->
                            </div>
                        </div>

                        <!-- Tab: Ghost Log (Profiles) -->
                        <div id="tab-log" class="tab-page hidden">
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">Known Ghost Profiles</h3>
                            <!-- Fixed Dropdown Styling -->
                            <select id="ghost-select" class="w-full p-3 rounded-md mb-3 border border-neon-purple focus:ring-soft-cyan focus:border-soft-cyan font-mono-data text-white bg-gray-900" onchange="displayGhostInfo()">
                                <option value="">--- Select Ghost Type ---</option>
                                <!-- Options populated by JS -->
                            </select>
                            <div id="ghost-info" class="text-sm h-[20rem] overflow-y-auto space-y-2 log-container">
                                <p class="text-gray-400 font-mono-data">Select a ghost from the list above to view its profile, evidence, strengths, and weaknesses.</p>
                            </div>
                        </div>

                        <!-- Tab: Case Files Gallery -->
                        <div id="tab-casefiles" class="tab-page hidden">
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">Poster Case Files</h3>
                            <div id="case-files-gallery" class="grid grid-cols-2 gap-4">
                                <!-- Images injected here -->
                            </div>
                        </div>

                        <!-- Tab: Lobby (Profile Setup) -->
                        <div id="tab-lobby" class="tab-page hidden">
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">User Profile Setup</h3>
                            <div class="space-y-4">
                                <div>
                                    <label for="display-name-input" class="block text-sm font-mono-data text-soft-cyan mb-1">Display Name</label>
                                    <input type="text" id="display-name-input" placeholder="Enter investigator name" class="w-full p-2 bg-deep-black border border-neon-purple rounded-md focus:ring-soft-cyan focus:border-soft-cyan text-soft-cyan font-mono-data">
                                </div>
                                <div>
                                    <label for="photo-select" class="block text-sm font-mono-data text-soft-cyan mb-1">Select Profile Photo</label>
                                    <!-- Fixed Dropdown Styling -->
                                    <select id="photo-select" class="w-full p-3 bg-gray-900 border border-neon-purple rounded-md focus:ring-soft-cyan focus:border-soft-cyan text-white font-mono-data" onchange="document.getElementById('profile-preview').src = this.value;">
                                        <!-- Options populated by JS -->
                                    </select>
                                </div>
                                <div class="flex justify-center items-center space-x-4">
                                    <img id="profile-preview" class="w-16 h-16 rounded-full object-cover border-2 border-soft-cyan shadow-md" src="" alt="Profile Preview">
                                    <button onclick="saveUserProfile()" class="phasmo-btn font-orbitron py-2 px-4 uppercase text-sm">
                                        Save Profile
                                    </button>
                                </div>
                            </div>
                            <h3 class="text-lg font-orbitron text-soft-cyan mt-6 mb-3">Voice Comms</h3>
                            <button onclick="openJitsi()" class="phasmo-btn font-orbitron py-3 px-4 uppercase text-sm w-full">
                                <i class="fas fa-headset mr-2"></i> Open Voice Channel
                            </button>
                        </div>
                        
                        <!-- Tab: Squad Status (Moved here from main page) -->
                        <div id="tab-squad" class="tab-page hidden">
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">Map Location</h3>
                            <div id="map-location-image-container" class="mb-4">
                                <!-- Map image will be injected here -->
                                <img id="map-location-image" src="https://placehold.co/600x300/0a0a0f/5dfdff?text=Current+Map+Not+Set+%21location" alt="Current Map Location" class="w-full h-auto object-cover rounded-lg border-2 border-soft-cyan shadow-xl">
                                <div id="map-location-name" class="mt-2 text-center font-orbitron text-xl text-white tracking-wider">TRUCK COMMAND</div>
                            </div>
                            
                            <h3 class="text-lg font-orbitron text-soft-cyan mb-3">Squad Health & Location</h3>
                            <div id="status-display" class="space-y-4 max-h-[15rem] overflow-y-auto">
                                <!-- Status list will be injected here -->
                            </div>
                            <p class="text-xs text-gray-500 font-mono-data mt-4">Cmds: <span class="text-soft-cyan">!dead: NAME</span>, <span class="text-soft-cyan">!location: MapName/Room</span></p>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Modal for Case File Details (Hidden by default) -->
    <div id="case-file-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center z-50 hidden">
        <div class="modal-content p-8 max-w-lg w-full rounded-xl transform transition-all duration-300 scale-95 opacity-0">
            <button onclick="closeModal()" class="absolute top-4 right-4 text-soft-cyan text-2xl hover:text-white transition duration-150">
                <i class="fas fa-times-circle"></i>
            </button>
            <img id="modal-image" class="w-full h-auto object-cover rounded-lg mb-6 border-2 border-neon-purple shadow-xl" src="" alt="Case File">
            <h3 id="modal-title" class="phasmo-title text-3xl font-orbitron mb-3 text-center"></h3>
            <p id="modal-description" class="text-sm text-gray-300 font-mono-data text-center"></p>
        </div>
    </div>

    <script type="module">
        // --- FIREBASE INITIALIZATION AND SETUP ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let firebaseConfig = {};
        try {
            firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        } catch (e) {
            // Non-fatal error, logging only
            console.error("Config Parsing Error:", e);
        }
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;
        let currentUserData = { id: 'unknown', name: 'Unknown Investigator', photoUrl: '' };
        let allUserProfiles = {};
        let initialAuthCheckComplete = false;
        let currentMap = { name: "TRUCK COMMAND", url: "https://placehold.co/600x300/0a0a0f/5dfdff?text=Current+Map+Not+Set+%21location" }; // Global map state
        
        // --- MAP LOCATIONS DATA (NEW) ---
        const MAP_LOCATIONS = {
            "Grafton": { url: 'uploaded:download (6).jpg-db6767d7-4f0b-4867-aeb6-51020bc57f79', name: "Grafton Farmhouse" },
            "Tanglewood": { url: 'uploaded:download (3).jpg-eacb7319-40d0-4b4e-8340-cb4379983c58', name: "Tanglewood Street House" },
            "Edgefield": { url: 'uploaded:download (2).jpg-a1ea7086-bfc1-4de3-b5f2-e5517fcc6421', name: "Edgefield Street House" },
            "Ridgeview": { url: 'uploaded:download (4).jpg-b276ed4f-d026-4056-a09a-ef1b43aba0d7', name: "Ridgeview Road House" },
            "Willow": { url: 'uploaded:download (5).jpg-1470f8c8-7034-4fd1-89b8-c2052b86c9bb', name: "Willow Street House" },
            "Bleasdale": { url: 'uploaded:download (1).jpg-ef3fd895-2f15-460a-b088-daf22c2ec1d9', name: "Bleasdale Farmhouse" },
            "Brownstone": { url: 'uploaded:ChatGPT Image Nov 30, 2025, 09_01_36 AM.jpg-2ad147c1-1370-4711-889d-b198370f2616', name: "Brownstone High School" },
            "Asylum": { url: 'uploaded:ChatGPT Image Nov 30, 2025, 09_01_36 AM.jpg-2ad147c1-1370-4711-889d-b198370f2616', name: "Sunny Meadows" },
            "Camp": { url: 'uploaded:download (1).jpg-ef3fd895-2f15-460a-b088-daf22c2ec1d9', name: "Camp Woodwind" }
        };


        // Firestore Collection Paths (Public Data)
        const CHAT_COLLECTION_PATH = `/artifacts/${appId}/public/data/chat_messages`;
        const EVENTS_COLLECTION_PATH = `/artifacts/${appId}/public/data/global_events`;
        const EVIDENCE_COLLECTION_PATH = `/artifacts/${appId}/public/data/evidence_tracker`;
        const STATUS_COLLECTION_PATH = `/artifacts/${appId}/public/data/player_status`;
        const PROFILES_COLLECTION_PATH = `/artifacts/${appId}/public/data/user_profiles`;
        const LOG_COLLECTION_PATH = `/artifacts/${appId}/public/data/ghost_log`;


        // --- UTILITY FUNCTIONS (Internal) ---

        /** Displays a temporary, self-hiding alert message */
        const alertBox = (message, bgColorClass = 'bg-blue-500', duration = 3000) => {
            const box = document.getElementById('alert-box');
            box.textContent = message;
            box.className = `fixed top-6 right-6 z-50 p-4 rounded-lg shadow-xl transition-opacity duration-300 ${bgColorClass}`;
            box.classList.remove('hidden', 'opacity-0');
            box.classList.add('opacity-100');

            setTimeout(() => {
                box.classList.remove('opacity-100');
                box.classList.add('opacity-0');
                setTimeout(() => box.classList.add('hidden'), 300);
            }, duration);
        };

        /** Formats a Date object to HH:MM:SS */
        const formatTime = (timestamp) => {
            if (!timestamp) return '';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        };

        /** Gets the user's display name, falling back to a default if profile not found. */
        const getDisplayName = (userId) => {
            const profile = allUserProfiles[userId];
            return profile ? profile.displayName : `User:${userId.substring(0, 4)}`;
        };

        /** Gets the user's profile photo URL, falling back to a placeholder. */
        const getPhotoUrl = (userId) => {
            const profile = allUserProfiles[userId];
            return profile && profile.photoUrl ? profile.photoUrl : 'https://placehold.co/50x50/111827/5dfdff?text=U';
        };
        
        /** Routes the command to the correct handler function. */
        const handleCommand = (command, value, fullCommand) => {
            const timestamp = Date.now();

            // Ghost Command: Triggers global event
            if (['hunt', 'flicker', 'manifest', 'curse', 'slam', 'event'].includes(command)) {
                window.triggerGlobalEvent(command);
            }
            // Evidence Command: Saves evidence
            else if (command === 'evidence' && value) {
                saveEvidence(value, timestamp);
            }
            // Status Command: Updates player death/revive status
            else if (command === 'dead' && value) {
                updatePlayerStatus(value, true, timestamp);
            }
            else if (command === 'revive' && value) {
                updatePlayerStatus(value, false, timestamp);
            }
            // Location Command: Updates player location
            else if (command === 'location' && value) {
                updatePlayerLocation(value, timestamp);
            }
            else {
                alertBox(`Unknown command: !${command}`, 'bg-yellow-500');
            }

            // Always log the original command to chat (handled inside sendChat if isCommand=true)
            sendChat(fullCommand, true);
        };
        
        /** Clears old event documents from the events collection to prevent re-triggering. */
        const clearOldEvents = async () => {
            try {
                if (!db) return; // Check db readiness
                const eventsRef = collection(db, EVENTS_COLLECTION_PATH);
                const eventsSnapshot = await getDocs(eventsRef);

                const batch = db.batch();
                eventsSnapshot.docs.forEach((doc) => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                console.log("Cleared old global events.");
            } catch (e) {
                console.warn("Could not clear old global events. Firestore might not be fully ready.", e);
            }
        };

        /** Executes the local visual and audio scare effect. */
        const triggerLocalScare = (eventType, intensity, timestamp, eventId) => {
            const body = document.body;
            const emfBar = document.getElementById('emf-bar');
            const emfText = document.getElementById('emf-level-text');

            // --- EMF VISUALS ---
            const width = intensity * 20; // 1-5 maps to 20% - 100%
            let color;
            if (intensity <= 2) { color = 'bg-yellow-400'; }
            else if (intensity <= 4) { color = 'bg-orange-500'; }
            else { color = 'bg-red-600'; }

            emfBar.style.width = `${width}%`;
            emfBar.className = `emf-bar h-full ${color}`;
            emfText.textContent = `EMF ${intensity}`;
            setTimeout(() => {
                // Decay the EMF reading after a short burst
                emfBar.style.width = '0%';
                emfBar.className = 'emf-bar h-full';
                emfText.textContent = 'OFF';
            }, 3000);

            // --- VISUAL EFFECTS ---
            if (eventType === 'hunt' || eventType === 'slam' || eventType === 'curse') {
                body.classList.add('scare-shake');
                setTimeout(() => body.classList.remove('scare-shake'), 1500);
            }
            if (eventType === 'flicker' || eventType === 'manifest') {
                body.classList.add('scare-flicker');
                setTimeout(() => body.classList.remove('scare-flicker'), 1000);
            }

            // --- AUDIO EFFECT (Tone.js) ---
            try {
                const Tone = window.Tone;
                if (!Tone) {
                    // Wait and retry if Tone.js is not yet loaded
                    setTimeout(() => triggerLocalScare(eventType, intensity, timestamp, eventId), 100);
                    throw new Error("Tone.js not loaded yet. Retrying...");
                }
                
                if (Tone.context.state !== 'running') {
                    Tone.context.resume();
                }

                // Low-frequency burst (classic horror effect)
                const synth = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.01, release: 1 }
                }).toDestination();

                const filter = new Tone.Filter({ type: 'lowpass', frequency: 1000 }).toDestination();
                synth.connect(filter);

                const volume = intensity / 5; // Louder for higher intensity
                synth.volume.value = -10 + (volume * 10); // Adjust volume for loudness

                synth.triggerAttackRelease("1s");

            } catch (e) {
                // Only log if it's the final error, not the "Retrying..." message
                if (e.message !== "Tone.js not loaded yet. Retrying...") {
                    console.error("Tone.js Audio Error:", e);
                    alertBox('Warning: Audio failed to play. Check console for Tone.js error.', 'bg-yellow-600', 4000);
                } else {
                    console.warn(e.message);
                }
            }

            // Clean up the event document after it has triggered the scare
            if (db) {
                setTimeout(async () => {
                    await deleteDoc(doc(db, EVENTS_COLLECTION_PATH, eventId));
                }, 2000); // 2 seconds after trigger
            }
        };

        // --- FIREBASE WRITE OPERATIONS (Internal) ---

        /** Sends a message to the chat and log. Handles commands. */
        const sendChat = async (message, isCommand = false) => {
            if (!db || !currentUserData.id || message.trim() === '') return;

            const chatRef = collection(db, CHAT_COLLECTION_PATH);
            const logRef = collection(db, LOG_COLLECTION_PATH);
            const timestamp = Date.now();

            await addDoc(chatRef, {
                userId: currentUserData.id,
                message: message,
                timestamp: timestamp,
                isCommand: isCommand
            });

            // Log command activity separately
            if (isCommand) {
                await addDoc(logRef, {
                    timestamp: timestamp,
                    source: 'USER',
                    type: 'COMMAND',
                    message: `${getDisplayName(currentUserData.id)} executed command: ${message}`
                });
            }
        };

        /** Adds a new piece of evidence to the Evidence Tracker */
        const saveEvidence = async (evidence, timestamp) => {
            if (!db) return;
            const evidenceRef = collection(db, EVIDENCE_COLLECTION_PATH);

            await addDoc(evidenceRef, {
                userId: currentUserData.id,
                evidence: evidence,
                timestamp: timestamp
            });
            alertBox(`Evidence logged: ${evidence}`, 'bg-neon-purple');
        };

        /** Updates a player's death/revive status */
        const updatePlayerStatus = async (nameOrId, isDead, timestamp) => {
            if (!db) return;
            const statusRef = collection(db, STATUS_COLLECTION_PATH);

            // Find the target user ID by display name or default to current user
            const targetId = Object.keys(allUserProfiles).find(id => allUserProfiles[id].displayName.toLowerCase() === nameOrId.toLowerCase()) || currentUserData.id;
            const targetName = getDisplayName(targetId);

            // Use setDoc with the user's ID as the document ID for the status collection
            await setDoc(doc(statusRef, targetId), {
                userId: targetId,
                isDead: isDead,
                timestamp: timestamp,
                location: allUserProfiles[targetId]?.location || 'Truck' // Keep current location
            }, { merge: true });

            const action = isDead ? 'DECLARED DEAD' : 'REVIVED';
            alertBox(`${targetName} ${action}!`, isDead ? 'bg-red-500' : 'bg-green-500');
        };

        /** Updates a player's location and the global map if a map name is used. */
        const updatePlayerLocation = async (locationInput, timestamp) => {
            if (!db) return;
            const statusRef = collection(db, STATUS_COLLECTION_PATH);

            // 1. Determine if the location is a map name or a room name
            const location = locationInput.trim();
            const locationLower = location.toLowerCase();
            let mapName = null;
            let roomName = location;

            // Check if the location is one of the known maps
            const foundMap = Object.keys(MAP_LOCATIONS).find(map => map.toLowerCase() === locationLower);
            
            if (foundMap) {
                mapName = foundMap;
                roomName = "Unknown Room"; // Default room if only map is provided
            } else {
                // If it's a room, we check if it has a map prefix (e.g., Tanglewood/Living Room)
                const locationParts = location.split(/\s*[\/]\s*/); // Split by / only for map/room
                if (locationParts.length > 1) {
                    const prefix = locationParts[0].trim();
                    const matchedPrefix = Object.keys(MAP_LOCATIONS).find(map => map.toLowerCase() === prefix.toLowerCase());

                    if (matchedPrefix) {
                        mapName = matchedPrefix;
                        roomName = locationParts.slice(1).join('/'); // Allow room names to contain slashes if needed
                    }
                }
            }
            
            // 2. Fetch current status to preserve death status and old map if none specified
            const statusDocRef = doc(statusRef, currentUserData.id);
            let currentStatus = { isDead: false, location: 'Truck', map: null };
            try {
                const docSnap = await getDoc(statusDocRef);
                if (docSnap.exists()) {
                    currentStatus = docSnap.data();
                }
            } catch (e) {
                console.error("Error fetching current status:", e);
            }
            
            // If a new map name was found, use it. Otherwise, keep the current map.
            const newMap = mapName || currentStatus.map;
            // Use roomName for the location display, NOT the raw input if it was parsed
            const newLocation = roomName;

            // 3. Update Firestore
            await setDoc(statusDocRef, {
                userId: currentUserData.id,
                location: newLocation,
                map: newMap, // Save the map name for global sync
                timestamp: timestamp,
                isDead: currentStatus.isDead
            }, { merge: true });

            alertBox(`Location updated: ${newLocation}`, 'bg-neon-purple');
        };
        
        /** Updates the global map image display. */
        const updateMapDisplay = (mapName = currentMap.name, mapUrl = currentMap.url) => {
            const mapImg = document.getElementById('map-location-image');
            const mapNameDiv = document.getElementById('map-location-name');
            
            // Default placeholder if URL is invalid or missing
            if (!mapUrl) mapUrl = "https://placehold.co/600x300/0a0a0f/5dfdff?text=Current+Map+Not+Set+%21location";

            if (mapImg) mapImg.src = mapUrl;
            if (mapNameDiv) mapNameDiv.textContent = mapName || "UNKNOWN LOCATION";
            
            // Update global state
            currentMap.name = mapName;
            currentMap.url = mapUrl;
        };

        /** Renders the Case Files gallery thumbnails. */
        const renderCaseFiles = () => {
            const gallery = document.getElementById('case-files-gallery');
            gallery.innerHTML = '';
            broadsImages.forEach((img, index) => {
                const imgElement = document.createElement('img');
                imgElement.src = img.url;
                imgElement.alt = img.title;
                imgElement.className = 'w-full h-32 object-cover rounded-lg border-2 border-neon-purple hover:border-soft-cyan cursor-pointer shadow-lg transition duration-150';
                imgElement.onclick = () => window.openModal(index);
                gallery.appendChild(imgElement);
            });
        };
        
        /** Populates the profile photo select dropdown and updates the preview */
        const setupProfileUI = () => {
            const photoSelect = document.getElementById('photo-select');
            const profilePreview = document.getElementById('profile-preview');

            // Clear existing options
            photoSelect.innerHTML = '';

            broadsImages.forEach((img, index) => {
                const option = document.createElement('option');
                option.value = img.url;
                option.textContent = img.title;
                photoSelect.appendChild(option);
            });

            // Set default values and preview
            photoSelect.value = broadsImages[0].url;
            profilePreview.src = broadsImages[0].url;

            // Load saved data if it exists
            const profileRef = doc(db, PROFILES_COLLECTION_PATH, currentUserData.id);
            getDoc(profileRef).then(docSnap => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    document.getElementById('display-name-input').value = data.displayName;
                    document.getElementById('photo-select').value = data.photoUrl;
                    document.getElementById('profile-preview').src = data.photoUrl;
                    currentUserData.name = data.displayName;
                    currentUserData.photoUrl = data.photoUrl;
                }
            }).catch(e => console.error("Could not load user profile on startup:", e));
        };
        
        // --- GHOST DATA ---
        const GHOST_PROFILES = {
            Spirit: { evidence: ["EMF 5", "Spirit Box", "Writing"], strength: "None.", weakness: "Smudge sticks prevent a hunt for a long time." },
            Wraith: { evidence: ["EMF 5", "Spirit Box", "DOTS"], strength: "Cannot be tracked by footsteps and rarely touches the ground.", weakness: "Toxic to salt, which causes it to stop hunting." },
            Phantom: { evidence: ["Spirit Box", "Fingerprints", "DOTS"], strength: "Appears for a shorter time when taking its photo, and wandering lowers sanity.", weakness: "Taking its photo makes it disappear immediately." },
            Poltergeist: { evidence: ["Spirit Box", "Fingerprints", "Throwing"], strength: "Can throw multiple objects at once, draining sanity rapidly.", weakness: "Becomes weak when objects are cleared from the room." },
            Banshee: { evidence: ["Fingerprints", "DOTS", "Orb"], strength: "Targets only one player at a time. Has a unique parabolic microphone sound.", weakness: "Fears the Crucifix and will act less aggressively when near one." },
            Jinn: { evidence: ["EMF 5", "Fingerprints", "Freezing"], strength: "Very fast when far from its victim.", weakness: "Cannot use its ability when the location's power is off." },
            Mare: { evidence: ["Spirit Box", "Orb", "Freezing"], strength: "More likely to attack in the dark. Will actively try to turn off lights.", weakness: "Turning on lights significantly reduces its attack chance." },
            Revenant: { evidence: ["Orb", "Writing", "Freezing"], strength: "Extremely fast during a hunt, but very slow when not hunting.", weakness: "Moving away and hiding will greatly reduce the chance of it finding you." },
            Shade: { evidence: ["EMF 5", "Writing", "Freezing"], strength: "Shy ghost. Rarely shows itself when multiple people are nearby. Less active.", weakness: "Cannot start a hunt if there is more than one person in the room." },
            Demon: { evidence: ["Fingerprints", "Writing", "Freezing"], strength: "Can initiate a hunt much sooner than any other ghost.", weakness: "Successful use of a Crucifix will block a hunt for a longer duration." },
            Yurei: { evidence: ["Orb", "Freezing", "DOTS"], strength: "Extreme sanity drain on players. Can completely close doors.", weakness: "Smudging the room will prevent it from leaving the ghost room for a long period." },
            Oni: { evidence: ["EMF 5", "Freezing", "DOTS"], strength: "More active when people are nearby. Physically manifests more often.", weakness: "Easier to identify due to its high activity." },
            Yokai: { evidence: ["Spirit Box", "Orb", "DOTS"], strength: "Attacks are more likely when people are speaking nearby.", weakness: "Cannot sense voices from far away." },
            Hantu: { evidence: ["Fingerprints", "Orb", "Freezing"], strength: "Faster in colder areas and significantly slower in warmer areas.", weakness: "Will leave behind clear Freezing Temperatures evidence." },
            Goryo: { evidence: ["EMF 5", "Fingerprints", "DOTS"], strength: "Rarely shows up far from its ghost room.", weakness: "Only visible through a video camera when no one is near." },
            Myling: { evidence: ["EMF 5", "Fingerprints", "Writing"], strength: "Quiet during hunts, making it hard to hear approach.", weakness: "Its paranormal sounds can be picked up from farther away on the parabolic mic." },
            Onryo: { evidence: ["Spirit Box", "Orb", "Freezing"], strength: "Increased chance to hunt after a flame goes out.", weakness: "Flames (candles/lighters) act as a Crucifix, preventing a hunt." },
            Twins: { evidence: ["Spirit Box", "EMF 5", "Freezing"], strength: "Can attack from multiple locations at once, one slower and one faster.", weakness: "Causes two different EMF signals at the same time." },
            Raiju: { evidence: ["EMF 5", "DOTS", "Orb"], strength: "Moves significantly faster near active electronics.", weakness: "Can be easily detected by high levels of EMF near devices." },
            Obake: { evidence: ["EMF 5", "Fingerprints", "Orb"], strength: "Can leave unique six-fingered fingerprints. Fingerprints disappear faster.", weakness: "High chance of not leaving Fingerprints at all." },
            Mimic: { evidence: ["Spirit Box", "Freezing", "Fingerprints", "Orb"], strength: "Mimics the behavior and evidence of other ghosts.", weakness: "Always provides Ghost Orb evidence, even when copying a ghost that doesn't." },
            Moroi: { evidence: ["Spirit Box", "Writing", "Freezing"], strength: "Curses victims, causing heavy and permanent sanity drain.", weakness: "Smudge sticks blind the Moroi for a long period." },
            Deogen: { evidence: ["Spirit Box", "Writing", "DOTS"], strength: "Fast when far away from a victim, but slows dramatically when close.", weakness: "Can be easily avoided by looping/kiting once you are close." },
            Thaye: { evidence: ["Orb", "Writing", "DOTS"], strength: "Very fast and active when first encountered.", weakness: "Gets progressively slower and less active the longer you stay in the location." }
        };
        
        // --- CASE FILE IMAGE DATA ---
        const broadsImages = [
            {
                url: 'uploaded:ChatGPT Image Nov 25, 2025, 01_35_48 PM.jpg-7014679f-7dae-4950-8a60-3be792d5e2d7',
                title: 'The Silent Approach',
                description: 'Case File 001: First encounter at Brownstone High School. The spirit was initially docile, but the EMF readings were undeniable. We held our ground.'
            },
            {
                url: 'uploaded:ChatGPT Image Nov 25, 2025, 06_40_24 PM.jpg-c71ef459-c9c8-49db-8ceb-0ecf6d9b79f9',
                title: 'Closet Panic',
                description: 'Case File 002: Trapped in a closet during a hunt. A quick prayer and a lucky EMF reader saved us from a close-quarters Manifestation. High terror levels.'
            },
            {
                url: 'uploaded:ChatGPT Image Nov 25, 2025, 06_58_04 PM.jpg-b8486f5c-1e51-4dac-9741-6c78b3c12867',
                title: 'Emergency Extraction',
                description: 'Case File 003: Subject down and dragged back to the van. A fast-moving Demon cut off our escape. Lesson learned: always keep the smudge sticks ready.'
            },
            {
                url: 'uploaded:ChatGPT Image Nov 25, 2025, 07_06_20 PM.jpg-e1a2c609-c596-4333-8169-442227b57a27',
                title: 'Ouija Board Gamble',
                description: 'Case File 004: Pushing the limits with the Ouija Board. We confirmed the ghost\'s name, but the consequences were immediate. Sanity dropped to zero.'
            },
            {
                url: 'uploaded:ChatGPT Image Nov 25, 2025, 07_27_30 PM.jpg-76b5f1cb-aa70-47fc-99a3-5a94c0da18d3',
                title: 'The Voodoo Threat',
                description: 'Case File 005: Encounter with a Mimic using a Voodoo Doll. We narrowly avoided a fatal curse. This one was personal and aggressive.'
            },
            {
                url: 'uploaded:ChatGPT Image Nov 25, 2025, 07_39_52 PM.jpg-04e2155e-c9c4-45af-bfaf-1af6cffbfda1',
                title: 'Circle of Summoning',
                description: 'Case File 006: Deliberate summoning ritual using candles and a salt circle. The ghost manifested immediately after the last word. High risk, high reward.'
            }
        ];


        // --- PUBLIC FUNCTIONS (Attached to window for HTML access) ---
        
        /** Parses the chat input for commands and executes the appropriate function. */
        window.handleChatInput = (event) => {
            if (event.key !== 'Enter') return;
            const input = document.getElementById('chat-input');
            let message = input.value.trim();

            if (message.startsWith('!')) {
                const parts = message.substring(1).split(':').map(s => s.trim());
                const command = parts[0].toLowerCase();
                const value = parts.length > 1 ? parts[1].trim() : '';

                handleCommand(command, value, message);
            } else if (message) {
                sendChat(message, false);
            }

            input.value = '';
        };

        /** Triggers a global event by writing to Firestore */
        window.triggerGlobalEvent = (eventType) => {
            // The async implementation is wrapped inside the function definition
            (async () => {
                if (!db) return;
                const eventsRef = collection(db, EVENTS_COLLECTION_PATH);
                const logRef = collection(db, LOG_COLLECTION_PATH);

                const intensity = Math.floor(Math.random() * 5) + 1; // EMF 1-5
                const timestamp = Date.now();

                await addDoc(eventsRef, {
                    type: eventType,
                    intensity: intensity,
                    timestamp: timestamp,
                    triggeredBy: currentUserData.id
                });

                await addDoc(logRef, {
                    timestamp: timestamp,
                    source: 'SYSTEM',
                    type: 'GHOST_EVENT',
                    message: `[${eventType.toUpperCase()}] EMF Level ${intensity} detected.`
                });
            })();
        };

        /** Sets the active tab */
        window.switchTab = (tabId) => {
            document.querySelectorAll('.tab-page').forEach(page => page.classList.add('hidden'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active-tab'));

            const contentElement = document.getElementById(`tab-${tabId}`);
            const buttonElement = document.getElementById(`tab-btn-${tabId}`);

            if (contentElement) contentElement.classList.remove('hidden');
            if (buttonElement) buttonElement.classList.add('active-tab');

            // Force scroll to bottom for chat/log when selected
            if (tabId === 'chat') {
                const chatMessagesDiv = document.getElementById('chat-messages');
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
            } else if (tabId === 'log') {
                const logDiv = document.getElementById('ghost-activity-log');
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        };

        /** Saves user profile data to Firestore */
        window.saveUserProfile = async () => {
            if (!db || !currentUserData.id) return alertBox('User not authenticated.', 'bg-red-500');

            const displayName = document.getElementById('display-name-input').value.trim();
            const photoUrl = document.getElementById('photo-select').value;

            if (displayName.length < 3) {
                return alertBox('Display name must be at least 3 characters.', 'bg-yellow-500');
            }

            const profileRef = doc(db, PROFILES_COLLECTION_PATH, currentUserData.id);

            await setDoc(profileRef, {
                displayName: displayName,
                photoUrl: photoUrl,
                lastSeen: Date.now()
            });

            // Update local data and UI immediately
            currentUserData.name = displayName;
            currentUserData.photoUrl = photoUrl;
            document.getElementById('user-id-display').textContent = `Investigator: ${displayName} (${currentUserData.id.substring(0, 8)}...)`;

            alertBox('Profile saved successfully!', 'bg-neon-purple');
        };

        /** Opens the modal with details for a specific image index. */
        window.openModal = (index) => {
            const image = broadsImages[index];
            document.getElementById('modal-image').src = image.url;
            document.getElementById('modal-title').textContent = image.title;
            document.getElementById('modal-description').textContent = image.description;

            const modal = document.getElementById('case-file-modal');
            modal.classList.remove('hidden');
            // Animate in
            setTimeout(() => {
                modal.querySelector('.modal-content').classList.remove('scale-95', 'opacity-0');
                modal.querySelector('.modal-content').classList.add('scale-100', 'opacity-100');
            }, 10);
        };

        /** Closes the modal. */
        window.closeModal = () => {
            const modal = document.getElementById('case-file-modal');
            // Animate out
            modal.querySelector('.modal-content').classList.remove('scale-100', 'opacity-100');
            modal.querySelector('.modal-content').classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        };

        /** Opens Jitsi link in a new tab. */
        window.openJitsi = () => {
            if (!currentUserData.id) return alertBox('Cannot open voice channel: Authentication in progress.', 'bg-yellow-500');
            const roomName = `PhasmoBroadsHQ_${appId}`;
            const displayName = getDisplayName(currentUserData.id);
            const jitsiUrl = `https://meet.jit.si/${roomName}#userInfo.displayName="${displayName}"`;
            window.open(jitsiUrl, '_blank');
        };
        
        /** GHOST LOG SETUP: Populates the Ghost Select dropdown */
        window.populateGhostSelect = () => {
            const select = document.getElementById('ghost-select');
            Object.keys(GHOST_PROFILES).sort().forEach(ghostName => {
                const option = document.createElement('option');
                option.value = ghostName;
                option.textContent = ghostName;
                select.appendChild(option);
            });
        };

        /** GHOST LOG SETUP: Displays Ghost Info based on selection */
        window.displayGhostInfo = () => {
            const select = document.getElementById('ghost-select');
            const infoDiv = document.getElementById('ghost-info');
            const ghostName = select.value;
            infoDiv.innerHTML = '';

            if (!ghostName) {
                infoDiv.innerHTML = '<p class="text-gray-400 font-mono-data">Select a ghost from the list above to view its profile, evidence, strengths, and weaknesses.</p>';
                return;
            }

            const profile = GHOST_PROFILES[ghostName];

            infoDiv.innerHTML = `
                <h4 class="text-xl font-orbitron text-soft-cyan">${ghostName}</h4>
                <div class="border-b border-neon-purple/50 pb-2 mb-2"></div>
                <p><span class="font-bold text-neon-purple">Evidence:</span> ${profile.evidence.join(', ')}</p>
                <p><span class="font-bold text-neon-purple">Strength:</span> ${profile.strength}</p>
                <p><span class="font-bold text-neon-purple">Weakness:</span> ${profile.weakness}</p>
            `;
        };

        // --- FIREBASE LISTENERS (Internal) ---

        /** Sets up listener for all user profiles for display name/photo sync */
        const setupProfileListener = () => {
            if (!db) return;
            const profilesRef = collection(db, PROFILES_COLLECTION_PATH);
            onSnapshot(profilesRef, (snapshot) => {
                allUserProfiles = {};
                snapshot.forEach(doc => {
                    const profile = doc.data();
                    allUserProfiles[doc.id] = {
                        displayName: profile.displayName || `User:${doc.id.substring(0, 4)}`,
                        photoUrl: profile.photoUrl || 'https://placehold.co/50x50/111827/5dfdff?text=U',
                        lastSeen: profile.lastSeen
                    };
                });
            }, (error) => {
                console.error("Error setting up profile listener:", error);
            });
        };

        /** Sets up listener for real-time chat messages */
        const setupChatroomListener = () => {
            if (!db) return;
            const chatRef = collection(db, CHAT_COLLECTION_PATH);
            const chatMessagesDiv = document.getElementById('chat-messages');

            onSnapshot(chatRef, (snapshot) => {
                const messages = [];
                snapshot.forEach(doc => {
                    messages.push({ id: doc.id, ...doc.data() });
                });

                // Sort by timestamp in memory (safer than using orderBy in query)
                messages.sort((a, b) => a.timestamp - b.timestamp);

                chatMessagesDiv.innerHTML = '';
                messages.forEach(msg => {
                    const displayName = getDisplayName(msg.userId);
                    const photoUrl = getPhotoUrl(msg.userId);

                    const messageElement = document.createElement('div');
                    messageElement.className = 'flex items-start space-x-3 log-entry';

                    const messageClass = msg.isCommand ? 'log-entry-command' : msg.isLog ? 'text-red-400' : 'text-gray-200';

                    messageElement.innerHTML = `
                        <img class="w-7 h-7 rounded-full object-cover border border-soft-cyan flex-shrink-0 mt-1" src="${photoUrl}" alt="${displayName}">
                        <div class="flex-grow">
                            <span class="text-xs text-gray-500 mr-2">${formatTime(msg.timestamp)}</span>
                            <span class="font-bold text-neon-purple">${displayName}:</span>
                            <span class="${messageClass}">${msg.message}</span>
                        </div>
                    `;
                    chatMessagesDiv.appendChild(messageElement);
                });
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
            }, (error) => {
                console.error("Error setting up chat listener:", error);
            });
        };

        /** Sets up listener for global ghost event triggers */
        const setupEventListener = () => {
            if (!db) return;
            const eventsRef = collection(db, EVENTS_COLLECTION_PATH);
            onSnapshot(eventsRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === "added") {
                        const eventData = change.doc.data();
                        const eventId = change.doc.id;
                        triggerLocalScare(eventData.type, eventData.intensity, eventData.timestamp, eventId);
                    }
                });
            }, (error) => {
                console.error("Error setting up event listener:", error);
            });
        };

        /** Sets up listener for the Evidence Tracker */
        const setupEvidenceListener = () => {
            if (!db) return;
            const evidenceRef = collection(db, EVIDENCE_COLLECTION_PATH);
            const evidenceDiv = document.getElementById('evidence-display');

            onSnapshot(evidenceRef, (snapshot) => {
                const evidenceList = [];
                snapshot.forEach(doc => evidenceList.push({ id: doc.id, ...doc.data() }));

                // Sort by timestamp
                evidenceList.sort((a, b) => a.timestamp - b.timestamp);

                evidenceDiv.innerHTML = '';
                evidenceList.forEach(item => {
                    evidenceDiv.innerHTML += `
                        <div class="p-3 border-l-4 border-soft-cyan bg-white/5 rounded-md flex justify-between items-center log-entry">
                            <span class="font-bold text-soft-cyan text-lg">${item.evidence}</span>
                            <span class="text-xs text-gray-400 ml-4">CONFIRMED by ${getDisplayName(item.userId)}</span>
                        </div>
                    `;
                });
                if (evidenceList.length === 0) {
                     evidenceDiv.innerHTML = '<p class="text-gray-500 italic p-2 font-mono-data">No evidence collected yet. Start a case!</p>';
                }
            }, (error) => {
                console.error("Error setting up evidence listener:", error);
            });
        };

        /** Sets up listener for Player Status and Location updates */
        const setupStatusListener = () => {
            if (!db) return;
            const statusRef = collection(db, STATUS_COLLECTION_PATH);
            const statusDiv = document.getElementById('status-display');
            const mapImage = document.getElementById('map-location-image');
            // Using a default placeholder URL that is NOT in MAP_LOCATIONS to ensure only actual map updates change it.
            const defaultMapUrl = 'https://placehold.co/600x300/0a0a0f/5dfdff?text=Current+Map+Not+Set+%21location'; 
            
            // Check if mapImage has been set by a previous status update
            let currentMapSet = mapImage.src !== defaultMapUrl;

            onSnapshot(statusRef, (snapshot) => {
                const statusMap = {};
                let mapUpdatedInSnapshot = false;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    statusMap[data.userId] = data;
                    
                    // Update global map if this user has set one AND it's a known map
                    if (data.map && MAP_LOCATIONS[data.map] && !mapUpdatedInSnapshot) {
                        mapImage.src = MAP_LOCATIONS[data.map].url;
                        mapImage.alt = `${data.map} Map Location`;
                        const mapNameDiv = document.getElementById('map-location-name');
                        if (mapNameDiv) {
                            mapNameDiv.textContent = MAP_LOCATIONS[data.map].name || data.map;
                        }
                        mapUpdatedInSnapshot = true;
                        currentMapSet = true;
                    }
                });

                if (!currentMapSet) {
                    mapImage.src = defaultMapUrl;
                    mapImage.alt = 'Select Map';
                }

                statusDiv.innerHTML = '';
                Object.values(statusMap).forEach(status => {
                    const displayName = getDisplayName(status.userId);
                    const photoUrl = getPhotoUrl(status.userId);
                    const isDead = status.isDead;
                    const statusClass = isDead ? 'border-red-500' : 'border-green-500';
                    const statusIcon = isDead ? '<i class="fas fa-skull text-red-500"></i>' : '<i class="fas fa-heartbeat text-green-500"></i>';
                    
                    // Show current location/room
                    const locationText = isDead ? 'DECEASED' : (status.location || 'Truck');
                    const locationIcon = isDead ? '' : `<i class="fas fa-map-marker-alt text-neon-purple mr-1"></i>`;

                    statusDiv.innerHTML += `
                        <div class="flex items-center space-x-3 p-4 rounded-lg border-2 ${statusClass} bg-white/5 log-entry">
                            <img class="w-10 h-10 rounded-full object-cover border-2 border-soft-cyan flex-shrink-0" src="${photoUrl}" alt="${displayName}">
                            <div class="flex-grow">
                                <span class="font-bold text-white text-lg font-orbitron">${displayName}</span>
                                <div class="text-sm text-gray-400 font-mono-data">${locationIcon}${locationText}</div>
                            </div>
                            <div class="text-3xl">${statusIcon}</div>
                        </div>
                    `;
                });
            }, (error) => {
                console.error("Error setting up status listener:", error);
            });
        };

        /** Sets up listener for the Ghost Activity Log */
        const setupLogListener = () => {
            if (!db) return;
            const logRef = collection(db, LOG_COLLECTION_PATH);
            const logDiv = document.getElementById('ghost-activity-log');

            onSnapshot(logRef, (snapshot) => {
                const logEntries = [];
                snapshot.forEach(doc => logEntries.push({ id: doc.id, ...doc.data() }));

                // Sort by timestamp
                logEntries.sort((a, b) => a.timestamp - b.timestamp);

                logDiv.innerHTML = '';
                logEntries.forEach(entry => {
                    const time = formatTime(entry.timestamp);
                    let logType, logClass, source;

                    if (entry.type === 'GHOST_EVENT') {
                        logType = 'EVENT';
                        logClass = 'log-entry-event';
                        source = 'SYSTEM';
                    } else if (entry.type === 'COMMAND') {
                        logType = 'COMMAND';
                        logClass = 'log-entry-command';
                        source = 'USER';
                    } else {
                        logType = 'CHAT';
                        logClass = 'text-gray-400';
                        source = getDisplayName(entry.userId) || 'SYSTEM';
                    }

                    logDiv.innerHTML += `
                        <p class="log-entry ${logClass}">[${time}] ${logType}  ${entry.message}</p>
                    `;
                });
                logDiv.scrollTop = logDiv.scrollHeight;
            }, (error) => {
                console.error("Error setting up log listener:", error);
            });
        };

        // --- INITIALIZATION ---

        const initializeAppAndAuth = () => {
            try {
                // Initialize Firebase services
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Use the provided custom token or sign in anonymously
                onAuthStateChanged(auth, async (user) => {
                    if (!initialAuthCheckComplete) {
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                user = auth.currentUser; // Update user after sign-in
                            } catch (error) {
                                console.error("Custom token sign-in failed, falling back to anonymous:", error);
                                await signInAnonymously(auth);
                                user = auth.currentUser;
                            }
                        } else if (!user) {
                            await signInAnonymously(auth);
                            user = auth.currentUser;
                        }
                        initialAuthCheckComplete = true;

                        // Post-Auth Initialization
                        if (user) {
                            currentUserData.id = user.uid;

                            // Set up all real-time listeners
                            setupProfileListener();
                            setupChatroomListener();
                            setupEventListener();
                            setupEvidenceListener();
                            setupStatusListener();
                            setupLogListener();
                            setupProfileUI(); // Load/Set up user profile UI

                            // Update UI status
                            const displayName = getDisplayName(currentUserData.id);
                            document.getElementById('user-id-display').textContent = `Investigator: ${displayName} (${currentUserData.id.substring(0, 8)}...)`;
                            alertBox('HQ Systems Online. Authentication Complete.', 'bg-green-600', 3000);

                            // Clean up old events (must be called after db is ready)
                            clearOldEvents();
                        } else {
                            alertBox('Authentication failed. App will run in limited mode.', 'bg-red-500', 5000);
                        }
                        
                        // FIX: Ensure switchTab is called after all setup is done to set initial state
                        window.switchTab('chat'); 
                    }
                });

                // Set up UI components that don't depend on auth
                renderCaseFiles();
                window.populateGhostSelect();
                window.displayGhostInfo();
            } catch (e) {
                alertBox('Fatal Initialization Error. Check console.', 'bg-red-500', 5000);
                console.error("Fatal Initialization Error:", e);
            }
        };

        window.onload = initializeAppAndAuth;
    </script>
</body>
</html>
